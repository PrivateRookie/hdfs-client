use prost::Message;

use crate::protocol::common::*;
use crate::protocol::hdfs::*;

use crate::IpcConnection;
use crate::IpcError;

/// generated by parsed ClientNamenodeProtocol service
impl IpcConnection {
    pub fn get_block_locations(
        &mut self,
        req: GetBlockLocationsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetBlockLocationsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getBlockLocations", &req)?;
        let resp = GetBlockLocationsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_server_defaults(
        &mut self,
        req: GetServerDefaultsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetServerDefaultsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getServerDefaults", &req)?;
        let resp = GetServerDefaultsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn append(
        &mut self,
        req: AppendRequestProto,
    ) -> Result<(RpcResponseHeaderProto, AppendResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("append", &req)?;
        let resp = AppendResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_replication(
        &mut self,
        req: SetReplicationRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetReplicationResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setReplication", &req)?;
        let resp = SetReplicationResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_storage_policy(
        &mut self,
        req: SetStoragePolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetStoragePolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setStoragePolicy", &req)?;
        let resp = SetStoragePolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn unset_storage_policy(
        &mut self,
        req: UnsetStoragePolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, UnsetStoragePolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("unsetStoragePolicy", &req)?;
        let resp = UnsetStoragePolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_storage_policy(
        &mut self,
        req: GetStoragePolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetStoragePolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getStoragePolicy", &req)?;
        let resp = GetStoragePolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_storage_policies(
        &mut self,
        req: GetStoragePoliciesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetStoragePoliciesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getStoragePolicies", &req)?;
        let resp = GetStoragePoliciesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_permission(
        &mut self,
        req: SetPermissionRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetPermissionResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setPermission", &req)?;
        let resp = SetPermissionResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_owner(
        &mut self,
        req: SetOwnerRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetOwnerResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setOwner", &req)?;
        let resp = SetOwnerResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn abandon_block(
        &mut self,
        req: AbandonBlockRequestProto,
    ) -> Result<(RpcResponseHeaderProto, AbandonBlockResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("abandonBlock", &req)?;
        let resp = AbandonBlockResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn add_block(
        &mut self,
        req: AddBlockRequestProto,
    ) -> Result<(RpcResponseHeaderProto, AddBlockResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("addBlock", &req)?;
        let resp = AddBlockResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_additional_datanode(
        &mut self,
        req: GetAdditionalDatanodeRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetAdditionalDatanodeResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getAdditionalDatanode", &req)?;
        let resp = GetAdditionalDatanodeResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn complete(
        &mut self,
        req: CompleteRequestProto,
    ) -> Result<(RpcResponseHeaderProto, CompleteResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("complete", &req)?;
        let resp = CompleteResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn report_bad_blocks(
        &mut self,
        req: ReportBadBlocksRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ReportBadBlocksResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("reportBadBlocks", &req)?;
        let resp = ReportBadBlocksResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn concat(
        &mut self,
        req: ConcatRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ConcatResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("concat", &req)?;
        let resp = ConcatResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn truncate(
        &mut self,
        req: TruncateRequestProto,
    ) -> Result<(RpcResponseHeaderProto, TruncateResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("truncate", &req)?;
        let resp = TruncateResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn rename(
        &mut self,
        req: RenameRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RenameResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("rename", &req)?;
        let resp = RenameResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn rename2(
        &mut self,
        req: Rename2RequestProto,
    ) -> Result<(RpcResponseHeaderProto, Rename2ResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("rename2", &req)?;
        let resp = Rename2ResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn delete(
        &mut self,
        req: DeleteRequestProto,
    ) -> Result<(RpcResponseHeaderProto, DeleteResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("delete", &req)?;
        let resp = DeleteResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn mkdirs(
        &mut self,
        req: MkdirsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, MkdirsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("mkdirs", &req)?;
        let resp = MkdirsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_listing(
        &mut self,
        req: GetListingRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetListingResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getListing", &req)?;
        let resp = GetListingResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn renew_lease(
        &mut self,
        req: RenewLeaseRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RenewLeaseResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("renewLease", &req)?;
        let resp = RenewLeaseResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn recover_lease(
        &mut self,
        req: RecoverLeaseRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RecoverLeaseResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("recoverLease", &req)?;
        let resp = RecoverLeaseResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_fs_stats(
        &mut self,
        req: GetFsStatusRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetFsStatsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getFsStats", &req)?;
        let resp = GetFsStatsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_datanode_report(
        &mut self,
        req: GetDatanodeReportRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetDatanodeReportResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getDatanodeReport", &req)?;
        let resp = GetDatanodeReportResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_datanode_storage_report(
        &mut self,
        req: GetDatanodeStorageReportRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            GetDatanodeStorageReportResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getDatanodeStorageReport", &req)?;
        let resp = GetDatanodeStorageReportResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_preferred_block_size(
        &mut self,
        req: GetPreferredBlockSizeRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetPreferredBlockSizeResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getPreferredBlockSize", &req)?;
        let resp = GetPreferredBlockSizeResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_safe_mode(
        &mut self,
        req: SetSafeModeRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetSafeModeResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setSafeMode", &req)?;
        let resp = SetSafeModeResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn save_namespace(
        &mut self,
        req: SaveNamespaceRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SaveNamespaceResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("saveNamespace", &req)?;
        let resp = SaveNamespaceResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn roll_edits(
        &mut self,
        req: RollEditsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RollEditsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("rollEdits", &req)?;
        let resp = RollEditsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn restore_failed_storage(
        &mut self,
        req: RestoreFailedStorageRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RestoreFailedStorageResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("restoreFailedStorage", &req)?;
        let resp = RestoreFailedStorageResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn refresh_nodes(
        &mut self,
        req: RefreshNodesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RefreshNodesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("refreshNodes", &req)?;
        let resp = RefreshNodesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn finalize_upgrade(
        &mut self,
        req: FinalizeUpgradeRequestProto,
    ) -> Result<(RpcResponseHeaderProto, FinalizeUpgradeResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("finalizeUpgrade", &req)?;
        let resp = FinalizeUpgradeResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn upgrade_status(
        &mut self,
        req: UpgradeStatusRequestProto,
    ) -> Result<(RpcResponseHeaderProto, UpgradeStatusResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("upgradeStatus", &req)?;
        let resp = UpgradeStatusResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn rolling_upgrade(
        &mut self,
        req: RollingUpgradeRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RollingUpgradeResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("rollingUpgrade", &req)?;
        let resp = RollingUpgradeResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_corrupt_file_blocks(
        &mut self,
        req: ListCorruptFileBlocksRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListCorruptFileBlocksResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listCorruptFileBlocks", &req)?;
        let resp = ListCorruptFileBlocksResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn meta_save(
        &mut self,
        req: MetaSaveRequestProto,
    ) -> Result<(RpcResponseHeaderProto, MetaSaveResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("metaSave", &req)?;
        let resp = MetaSaveResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_file_info(
        &mut self,
        req: GetFileInfoRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetFileInfoResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getFileInfo", &req)?;
        let resp = GetFileInfoResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_located_file_info(
        &mut self,
        req: GetLocatedFileInfoRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetLocatedFileInfoResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getLocatedFileInfo", &req)?;
        let resp = GetLocatedFileInfoResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn add_cache_pool(
        &mut self,
        req: AddCachePoolRequestProto,
    ) -> Result<(RpcResponseHeaderProto, AddCachePoolResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("addCachePool", &req)?;
        let resp = AddCachePoolResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn modify_cache_pool(
        &mut self,
        req: ModifyCachePoolRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ModifyCachePoolResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("modifyCachePool", &req)?;
        let resp = ModifyCachePoolResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_cache_pool(
        &mut self,
        req: RemoveCachePoolRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RemoveCachePoolResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeCachePool", &req)?;
        let resp = RemoveCachePoolResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_cache_pools(
        &mut self,
        req: ListCachePoolsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListCachePoolsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listCachePools", &req)?;
        let resp = ListCachePoolsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_file_link_info(
        &mut self,
        req: GetFileLinkInfoRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetFileLinkInfoResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getFileLinkInfo", &req)?;
        let resp = GetFileLinkInfoResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_content_summary(
        &mut self,
        req: GetContentSummaryRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetContentSummaryResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getContentSummary", &req)?;
        let resp = GetContentSummaryResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_quota(
        &mut self,
        req: SetQuotaRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetQuotaResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setQuota", &req)?;
        let resp = SetQuotaResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn fsync(
        &mut self,
        req: FsyncRequestProto,
    ) -> Result<(RpcResponseHeaderProto, FsyncResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("fsync", &req)?;
        let resp = FsyncResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_times(
        &mut self,
        req: SetTimesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetTimesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setTimes", &req)?;
        let resp = SetTimesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn create_symlink(
        &mut self,
        req: CreateSymlinkRequestProto,
    ) -> Result<(RpcResponseHeaderProto, CreateSymlinkResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("createSymlink", &req)?;
        let resp = CreateSymlinkResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_link_target(
        &mut self,
        req: GetLinkTargetRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetLinkTargetResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getLinkTarget", &req)?;
        let resp = GetLinkTargetResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn update_block_for_pipeline(
        &mut self,
        req: UpdateBlockForPipelineRequestProto,
    ) -> Result<(RpcResponseHeaderProto, UpdateBlockForPipelineResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("updateBlockForPipeline", &req)?;
        let resp = UpdateBlockForPipelineResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn update_pipeline(
        &mut self,
        req: UpdatePipelineRequestProto,
    ) -> Result<(RpcResponseHeaderProto, UpdatePipelineResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("updatePipeline", &req)?;
        let resp = UpdatePipelineResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_balancer_bandwidth(
        &mut self,
        req: SetBalancerBandwidthRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetBalancerBandwidthResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setBalancerBandwidth", &req)?;
        let resp = SetBalancerBandwidthResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_data_encryption_key(
        &mut self,
        req: GetDataEncryptionKeyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetDataEncryptionKeyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getDataEncryptionKey", &req)?;
        let resp = GetDataEncryptionKeyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn create_snapshot(
        &mut self,
        req: CreateSnapshotRequestProto,
    ) -> Result<(RpcResponseHeaderProto, CreateSnapshotResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("createSnapshot", &req)?;
        let resp = CreateSnapshotResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn rename_snapshot(
        &mut self,
        req: RenameSnapshotRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RenameSnapshotResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("renameSnapshot", &req)?;
        let resp = RenameSnapshotResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn allow_snapshot(
        &mut self,
        req: AllowSnapshotRequestProto,
    ) -> Result<(RpcResponseHeaderProto, AllowSnapshotResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("allowSnapshot", &req)?;
        let resp = AllowSnapshotResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn disallow_snapshot(
        &mut self,
        req: DisallowSnapshotRequestProto,
    ) -> Result<(RpcResponseHeaderProto, DisallowSnapshotResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("disallowSnapshot", &req)?;
        let resp = DisallowSnapshotResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_snapshottable_dir_listing(
        &mut self,
        req: GetSnapshottableDirListingRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            GetSnapshottableDirListingResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getSnapshottableDirListing", &req)?;
        let resp = GetSnapshottableDirListingResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_snapshot_listing(
        &mut self,
        req: GetSnapshotListingRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetSnapshotListingResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getSnapshotListing", &req)?;
        let resp = GetSnapshotListingResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn delete_snapshot(
        &mut self,
        req: DeleteSnapshotRequestProto,
    ) -> Result<(RpcResponseHeaderProto, DeleteSnapshotResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("deleteSnapshot", &req)?;
        let resp = DeleteSnapshotResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_snapshot_diff_report(
        &mut self,
        req: GetSnapshotDiffReportRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetSnapshotDiffReportResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getSnapshotDiffReport", &req)?;
        let resp = GetSnapshotDiffReportResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_snapshot_diff_report_listing(
        &mut self,
        req: GetSnapshotDiffReportListingRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            GetSnapshotDiffReportListingResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getSnapshotDiffReportListing", &req)?;
        let resp = GetSnapshotDiffReportListingResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn is_file_closed(
        &mut self,
        req: IsFileClosedRequestProto,
    ) -> Result<(RpcResponseHeaderProto, IsFileClosedResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("isFileClosed", &req)?;
        let resp = IsFileClosedResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn modify_acl_entries(
        &mut self,
        req: ModifyAclEntriesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ModifyAclEntriesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("modifyAclEntries", &req)?;
        let resp = ModifyAclEntriesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_acl_entries(
        &mut self,
        req: RemoveAclEntriesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RemoveAclEntriesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeAclEntries", &req)?;
        let resp = RemoveAclEntriesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_default_acl(
        &mut self,
        req: RemoveDefaultAclRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RemoveDefaultAclResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeDefaultAcl", &req)?;
        let resp = RemoveDefaultAclResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_acl(
        &mut self,
        req: RemoveAclRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RemoveAclResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeAcl", &req)?;
        let resp = RemoveAclResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_acl(
        &mut self,
        req: SetAclRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetAclResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setAcl", &req)?;
        let resp = SetAclResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_acl_status(
        &mut self,
        req: GetAclStatusRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetAclStatusResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getAclStatus", &req)?;
        let resp = GetAclStatusResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_x_attr(
        &mut self,
        req: SetXAttrRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetXAttrResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setXAttr", &req)?;
        let resp = SetXAttrResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_x_attrs(
        &mut self,
        req: GetXAttrsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetXAttrsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getXAttrs", &req)?;
        let resp = GetXAttrsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_x_attrs(
        &mut self,
        req: ListXAttrsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListXAttrsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listXAttrs", &req)?;
        let resp = ListXAttrsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_x_attr(
        &mut self,
        req: RemoveXAttrRequestProto,
    ) -> Result<(RpcResponseHeaderProto, RemoveXAttrResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeXAttr", &req)?;
        let resp = RemoveXAttrResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn check_access(
        &mut self,
        req: CheckAccessRequestProto,
    ) -> Result<(RpcResponseHeaderProto, CheckAccessResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("checkAccess", &req)?;
        let resp = CheckAccessResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn create_encryption_zone(
        &mut self,
        req: CreateEncryptionZoneRequestProto,
    ) -> Result<(RpcResponseHeaderProto, CreateEncryptionZoneResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("createEncryptionZone", &req)?;
        let resp = CreateEncryptionZoneResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_encryption_zones(
        &mut self,
        req: ListEncryptionZonesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListEncryptionZonesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listEncryptionZones", &req)?;
        let resp = ListEncryptionZonesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn reencrypt_encryption_zone(
        &mut self,
        req: ReencryptEncryptionZoneRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ReencryptEncryptionZoneResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("reencryptEncryptionZone", &req)?;
        let resp = ReencryptEncryptionZoneResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_reencryption_status(
        &mut self,
        req: ListReencryptionStatusRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListReencryptionStatusResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listReencryptionStatus", &req)?;
        let resp = ListReencryptionStatusResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_e_z_for_path(
        &mut self,
        req: GetEzForPathRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetEzForPathResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getEZForPath", &req)?;
        let resp = GetEzForPathResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn set_erasure_coding_policy(
        &mut self,
        req: SetErasureCodingPolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SetErasureCodingPolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("setErasureCodingPolicy", &req)?;
        let resp = SetErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn unset_erasure_coding_policy(
        &mut self,
        req: UnsetErasureCodingPolicyRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            UnsetErasureCodingPolicyResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("unsetErasureCodingPolicy", &req)?;
        let resp = UnsetErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_e_c_topology_result_for_policies(
        &mut self,
        req: GetEcTopologyResultForPoliciesRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            GetEcTopologyResultForPoliciesResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getECTopologyResultForPolicies", &req)?;
        let resp = GetEcTopologyResultForPoliciesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_current_edit_log_txid(
        &mut self,
        req: GetCurrentEditLogTxidRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetCurrentEditLogTxidResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getCurrentEditLogTxid", &req)?;
        let resp = GetCurrentEditLogTxidResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_edits_from_txid(
        &mut self,
        req: GetEditsFromTxidRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetEditsFromTxidResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getEditsFromTxid", &req)?;
        let resp = GetEditsFromTxidResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_erasure_coding_policies(
        &mut self,
        req: GetErasureCodingPoliciesRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            GetErasureCodingPoliciesResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getErasureCodingPolicies", &req)?;
        let resp = GetErasureCodingPoliciesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn add_erasure_coding_policies(
        &mut self,
        req: AddErasureCodingPoliciesRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            AddErasureCodingPoliciesResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("addErasureCodingPolicies", &req)?;
        let resp = AddErasureCodingPoliciesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn remove_erasure_coding_policy(
        &mut self,
        req: RemoveErasureCodingPolicyRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            RemoveErasureCodingPolicyResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("removeErasureCodingPolicy", &req)?;
        let resp = RemoveErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn enable_erasure_coding_policy(
        &mut self,
        req: EnableErasureCodingPolicyRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            EnableErasureCodingPolicyResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("enableErasureCodingPolicy", &req)?;
        let resp = EnableErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn disable_erasure_coding_policy(
        &mut self,
        req: DisableErasureCodingPolicyRequestProto,
    ) -> Result<
        (
            RpcResponseHeaderProto,
            DisableErasureCodingPolicyResponseProto,
        ),
        IpcError,
    > {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("disableErasureCodingPolicy", &req)?;
        let resp = DisableErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_erasure_coding_policy(
        &mut self,
        req: GetErasureCodingPolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetErasureCodingPolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getErasureCodingPolicy", &req)?;
        let resp = GetErasureCodingPolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_erasure_coding_codecs(
        &mut self,
        req: GetErasureCodingCodecsRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetErasureCodingCodecsResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getErasureCodingCodecs", &req)?;
        let resp = GetErasureCodingCodecsResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_quota_usage(
        &mut self,
        req: GetQuotaUsageRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetQuotaUsageResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getQuotaUsage", &req)?;
        let resp = GetQuotaUsageResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn list_open_files(
        &mut self,
        req: ListOpenFilesRequestProto,
    ) -> Result<(RpcResponseHeaderProto, ListOpenFilesResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("listOpenFiles", &req)?;
        let resp = ListOpenFilesResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn msync(
        &mut self,
        req: MsyncRequestProto,
    ) -> Result<(RpcResponseHeaderProto, MsyncResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("msync", &req)?;
        let resp = MsyncResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn satisfy_storage_policy(
        &mut self,
        req: SatisfyStoragePolicyRequestProto,
    ) -> Result<(RpcResponseHeaderProto, SatisfyStoragePolicyResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("satisfyStoragePolicy", &req)?;
        let resp = SatisfyStoragePolicyResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_ha_service_state(
        &mut self,
        req: HaServiceStateRequestProto,
    ) -> Result<(RpcResponseHeaderProto, HaServiceStateResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getHAServiceState", &req)?;
        let resp = HaServiceStateResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }

    pub fn get_slow_datanode_report(
        &mut self,
        req: GetSlowDatanodeReportRequestProto,
    ) -> Result<(RpcResponseHeaderProto, GetSlowDatanodeReportResponseProto), IpcError> {
        let req = req.encode_length_delimited_to_vec();
        let (header, resp) = self.send_raw_req("getSlowDatanodeReport", &req)?;
        let resp = GetSlowDatanodeReportResponseProto::decode_length_delimited(resp)?;
        Ok((header, resp))
    }
}
